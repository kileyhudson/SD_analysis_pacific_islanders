#!/usr/bin/env python

#Filter segmental duplications by removing those that overlap with structural assembly errors generated by Inspector.
#run with run_filter_sd_by_structural_errors.sh (./run_filter_sd_by_structural_errors.sh)
#module load python3

import argparse
import os
import subprocess
import numpy as np
import re

parser = argparse.ArgumentParser()
parser.add_argument("--szGenomicSuperDup", required=True)
parser.add_argument("--szStructuralErrors", required=True)
parser.add_argument("--szSampleName", required=True,
                    help="Sample name (e.g., UPIS220008)")
parser.add_argument("--szHaplotype", required=True,
                    help="Haplotype (h1 or h2)")
parser.add_argument("--szOutputDir", default="/projects/standard/hsiehph/shared/DIR_homes/hudso501/analysisPI/data/filter_by_structural_errors")
args = parser.parse_args()

# Create output directory if it doesn't exist
os.makedirs(args.szOutputDir, exist_ok=True)

# Output file names
szFilteredSDs = os.path.join(args.szOutputDir, 
                            f"{args.szSampleName}.{args.szHaplotype}.filtered_by_structural_errors_SDs.bed")
szErrorOverlapSDs = os.path.join(args.szOutputDir, 
                                f"{args.szSampleName}.{args.szHaplotype}.structural_error_overlap_SDs.bed")

# Set up temporary directory
if 'TMPDIR' in os.environ:
    TMPDIR = os.environ['TMPDIR']
else:
    TMPDIR = "/tmp/" + os.environ['USER'] + "/" + str(os.getpid())
    szCommand = "mkdir -p " + TMPDIR
    subprocess.call(szCommand, shell=True)

def calculate_nonredundant_bp(filtered_sd_file, temp_dir):
    #Calculate non-redundant base pairs covered by filtered SDs
    
    # Create temporary bed file with all SD regions
    temp_bed = os.path.join(temp_dir, "temp_all_regions.bed")
    
    with open(filtered_sd_file, "r") as fSD, open(temp_bed, "w") as fBed:
        for line in fSD:
            if line.startswith('#'):
                continue
            
            fields = line.strip().split('\t')
            if len(fields) >= 9:
                # Extract both domains (chr, start, end)
                chr1, start1, end1 = fields[0], fields[1], fields[2]
                chr2, start2, end2 = fields[6], fields[7], fields[8]
                
                fBed.write(f"{chr1}\t{start1}\t{end1}\n")
                fBed.write(f"{chr2}\t{start2}\t{end2}\n")
    
    # Sort the bed file
    temp_bed_sorted = os.path.join(temp_dir, "temp_all_regions_sorted.bed")
    szCommand = f"sort -k1,1 -k2,2n {temp_bed} > {temp_bed_sorted}"
    subprocess.call(szCommand, shell=True)
    
    # Use bedtools merge and calculate total bases
    merge_output = os.path.join(temp_dir, "temp_merged.bed")
    szCommand = f"module load bedtools/2.29.2 && bedtools merge -i {temp_bed_sorted} > {merge_output}"
    subprocess.call(szCommand, shell=True)
    
    # Calculate total bases
    total_bp = 0
    with open(merge_output, "r") as fMerged:
        for line in fMerged:
            fields = line.strip().split('\t')
            if len(fields) >= 3:
                start = int(fields[1])
                end = int(fields[2])
                total_bp += (end - start)
    
    return total_bp


# Process structural errors only
szStructuralErrorsSorted = TMPDIR + "/structural_errors_sorted.bed"

# Extract just the first 3 columns (chr, start, end) from structural error file
# Skip header lines that start with '#'
szStructuralErrorsExtracted = TMPDIR + "/structural_errors_extracted.bed"
with open(szStructuralErrorsExtracted, "w") as fExtracted:
    # Process structural errors
    with open(args.szStructuralErrors, "r") as fStruct:
        for line in fStruct:
            if not line.startswith('#'):
                fields = line.strip().split('\t')
                if len(fields) >= 3:
                    # Handle HaplotypeSwitch format (positions with semicolons)
                    start_pos = fields[1].split(';')[0]
                    end_pos = fields[2].split(';')[0]
                    fExtracted.write(f"{fields[0]}\t{start_pos}\t{end_pos}\n")

# Sort the structural error file
szCommand = f"sort -k1,1 -k2,2n {szStructuralErrorsExtracted} > {szStructuralErrorsSorted}"
subprocess.call(szCommand, shell=True)

# process the segmental duplications file
# Split into left and right domains
szSDLeftDomain = TMPDIR + "/sd_left_domain.bed"
szSDRightDomain = TMPDIR + "/sd_right_domain.bed"

with open(args.szGenomicSuperDup, "r") as fSD, \
     open(szSDLeftDomain, "w") as fLeftDomain, \
     open(szSDRightDomain, "w") as fRightDomain:
    
    n1Line = 0
    while True:
        szLine = fSD.readline()
        if szLine == "":
            nNumberOfLinesInSD = n1Line
            break
        
        n1Line += 1
        
        if szLine.startswith('#'):
            continue
        
        aWords = re.split(r'\t|\n', szLine)
        
        # GenomicSuperDup.tab format:
        # chr1(0) start1(1) end1(2) strand1(3) fracMatch(4) strand2(5) 
        # chr2(6) start2(7) end2(8) ...
        
        szChr1 = aWords[0]
        szChr2 = aWords[6]
        nStart1 = int(aWords[1])
        nEnd1 = int(aWords[2])
        nStart2 = int(aWords[7])
        nEnd2 = int(aWords[8])
        
        # Use line number as name for tracking
        szName = str(n1Line)
        
        # Ensure consistent ordering
        if (szChr1 > szChr2) or (szChr1 == szChr2 and nStart1 > nStart2):
            # Swap
            (szChr1, nStart1, nEnd1, szChr2, nStart2, nEnd2) = \
                (szChr2, nStart2, nEnd2, szChr1, nStart1, nEnd1)
        
        # Write left domain (smaller coordinate)
        fLeftDomain.write(f"{szChr1}\t{nStart1}\t{nEnd1}\t{szName}\t{n1Line}\n")
        # Write right domain (larger coordinate)
        fRightDomain.write(f"{szChr2}\t{nStart2}\t{nEnd2}\t{szName}\t{n1Line}\n")

# Intersect left domains with structural errors
szLeftOverlaps = TMPDIR + "/left_domain_structural_error_overlaps.txt"
szCommand = f"module load bedtools/2.29.2 && bedtools intersect -u -a {szSDLeftDomain} -b {szStructuralErrorsSorted} > {szLeftOverlaps}"
subprocess.call(szCommand, shell=True)

# Intersect right domains with structural errors
szRightOverlaps = TMPDIR + "/right_domain_structural_error_overlaps.txt"
szCommand = f"module load bedtools/2.29.2 && bedtools intersect -u -a {szSDRightDomain} -b {szStructuralErrorsSorted} > {szRightOverlaps}"
subprocess.call(szCommand, shell=True)

# Collect line numbers of SDs that overlap with structural errors
aSDsWithErrors = np.zeros(nNumberOfLinesInSD + 1, dtype=bool)

# Process left domain overlaps
with open(szLeftOverlaps, "r") as fLeft:
    for line in fLeft:
        if line.strip():
            fields = line.strip().split('\t')
            if len(fields) >= 5:
                lineNumber = int(fields[4])
                aSDsWithErrors[lineNumber] = True

# Process right domain overlaps
with open(szRightOverlaps, "r") as fRight:
    for line in fRight:
        if line.strip():
            fields = line.strip().split('\t')
            if len(fields) >= 5:
                lineNumber = int(fields[4])
                aSDsWithErrors[lineNumber] = True

# Write filtered output
nTotalSDs = 0
nFilteredSDs = 0
nRemovedSDs = 0

with open(args.szGenomicSuperDup, "r") as fSD, \
     open(szFilteredSDs, "w") as fFiltered, \
     open(szErrorOverlapSDs, "w") as fErrorOverlap:
    
    n1Line = 0
    while True:
        szLine = fSD.readline()
        if szLine == "":
            break
        
        n1Line += 1
        
        if szLine.startswith('#'):
            continue
        
        nTotalSDs += 1
        
        if not aSDsWithErrors[n1Line]:
            # This SD does not overlap with structural errors - keep it
            fFiltered.write(szLine)
            nFilteredSDs += 1
        else:
            # This SD overlaps with structural errors - write to separate file
            fErrorOverlap.write(szLine)
            nRemovedSDs += 1

# Calculate non-redundant base pairs for filtered SDs
nonredundant_bp = calculate_nonredundant_bp(szFilteredSDs, TMPDIR)

# Calculate SD pairs (divide by 2 since each pair appears twice)
nTotalPairs = nTotalSDs // 2
nFilteredPairs = nFilteredSDs // 2
nRemovedPairs = nRemovedSDs // 2

# Print summary statistics
print("\n=== STRUCTURAL ERROR FILTERING SUMMARY ===")
print(f"Sample: {args.szSampleName} - {args.szHaplotype}")
print(f"Total SD pairs in input: {nTotalPairs}")
print(f"SD pairs overlapping with structural errors: {nRemovedPairs}")
print(f"SD pairs retained after filtering: {nFilteredPairs}")
print(f"Percentage removed: {(nRemovedPairs/nTotalPairs*100):.2f}%")
print(f"Nonredundant bp after filtering: {nonredundant_bp}")

# Create a summary file
szSummaryFile = os.path.join(args.szOutputDir, 
                            f"{args.szSampleName}.{args.szHaplotype}.structural_filtering_summary.txt")
with open(szSummaryFile, "w") as fSummary:
    fSummary.write(f"Sample\tHaplotype\tSD_pairs\tStructural_Error_Overlap_pairs\tFiltered_pairs\tPercent_Removed\tNonredundant_bp\n")
    fSummary.write(f"{args.szSampleName}\t{args.szHaplotype}\t{nTotalPairs}\t{nRemovedPairs}\t{nFilteredPairs}\t{(nRemovedPairs/nTotalPairs*100):.2f}\t{nonredundant_bp}\n")

# Clean up temporary files
if 'TMPDIR' not in os.environ:
    szCommand = f"rm -rf {TMPDIR}"
    subprocess.call(szCommand, shell=True)
